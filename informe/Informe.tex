\documentclass[11pt]{article}

% -------------- PREÁMBULO ---------------

\usepackage[spanish]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsbsy} % librerias ams
\usepackage{graphicx}           % Incluir imágenes en LaTeX
\usepackage{color}              % Para colorear texto
\usepackage{subfigure}          % subfiguras
\usepackage{float}              % Podemos usar el especificador [H] en las figuras para que se queden donde queramos
\usepackage{capt-of}            % Permite usar etiquetas fuera de elementos flotantes (etiquetas de figuras)
\usepackage[outputdir=aux]{minted} % Para colocar código
\usepackage{sidecap}            % Para poner el texto de las imágenes al lado
\sidecaptionvpos{figure}{c}     % Para que el texto se alinee al centro vertical
\usepackage{caption}            % Para poder quitar numeracion de figuras
\usepackage{anysize}            % Para personalizar el ancho de  los márgenes
\marginsize{2cm}{2cm}{2cm}{2cm} % Izquierda, derecha, arriba, abajo
\usepackage{multicol}
\usepackage{multirow}
\setlength{\columnsep}{1cm}

% Para agregar encabezado y pie de página
\usepackage{fancyhdr} 
\usepackage{clrscode3e} % Para agregar pseudocódigo

\usepackage{listings}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\footnotesize USB}                           % Encabezado izquierda
\fancyhead[R]{\footnotesize \texttt{monad-wordle}}      % Encabezado derecha
\fancyfoot[R]{\footnotesize Informe Proyecto I}            % Pie derecha
\fancyfoot[C]{\thepage}                                    % Centro
\fancyfoot[L]{\footnotesize Ingeniería de la Computación}  % Izquierda
\renewcommand{\footrulewidth}{0.4pt}

\newcommand{\coment}[1]{}
\definecolor{BurntOrange}{RGB}{247,148,42}

\begin{document}

% ----------------- PORTADA -----------------

\begin{center} 
   \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}  

   \begin{minipage}{0.48\textwidth}
      \begin{center}
         \includegraphics[scale = 0.8]{logotip.png}
      \end{center}
   \end{minipage}

   \vspace*{0.2cm}
   \textsc{\large Dpto. de Computación y Tecnología de la Información} \\ 
   \textsc{\large CI-3661 - Laboratorio de Lenguajes de Programación} \\ [4cm] 

   \vspace*{1cm}
   \HRule \\ [0.4cm]
   \textsc{\Large Proyecto I } \\ [0.4cm]
   {\Huge \bfseries \texttt{monad-wordle} - Una implementación en Haskell de Wordle para dos} \\ [0.4cm] 
   \HRule \\ [6cm]

   \begin{minipage}{\textwidth} 
      \begin{flushleft} \large    
         \textbf{\underline{Autor:}} \\ 
         Nestor González 16-10455 \\
         Christopher Gómez 18-10892 \\
      \end{flushleft}
   \end{minipage}

   \begin{minipage}{\textwidth}
      \vspace{-2cm}
      \begin{flushright} \large
         \textbf{\underline{Profesor:}} \\
         Fenando Torre 
      \end{flushright}
   \end{minipage} \\ [2cm]

   \begin{center}
      {\large \today}
   \end{center}
\end{center}

\newpage

% -------------------------------------------
\section{Introducción}


El siguiente informe consiste en dar un vistazo a una implementación en Haskell
del famoso juego Wordle, presentando las decisiones de diseño tomadas al 
programar la solución y los algoritmos usados para cada modo de juego, para obtener
de ello conclusiones que nos permitan dilucidar las características más relevantes
y distintivas del paradigma de programación funcional. \\

Wordle es un juego en línea que se popularizó alrededor de octubre del 2021, que
consiste en adivinar en 6 intentos o menos una palabra de 5 letras planteada por
la computadora, dadas unas pistas que indican cuáles letras de la adivinación son
acertadas y si están o no en la posición correcta. El juego se basa en otro llamado
"Toros y Vacas", y la implementación presentada trata sobre este, donde además se
introduce un modo en el que el jugador piensa una palabra y la computadora intenta
adivinarla. \\

Este último modo añade a la implementación una complejidad adicional, que es la de
diseñar un solucionador que intentará adivinar la palabra del usuario. Para este
solucionador se usa un algoritmo de Minimax para optimizar la adivinación, que se
explicará en la sección de diseño de la solución, junto a los demás modos y las
optimizaciones y problemas surgidos al modelar y programar. \\

Luego, el objetivo de implementar \texttt{monad-wordle} consiste en conocer las
herramientas que ofrece la programación funcional, y en especial Haskell, para
la resolución de problemas, así como descubrir nuevas maneras de plantearlos y pensar
sobre ellos, explotando las bondades que ofrece este paradigma.

\section{Diseño de la solución}

\texttt{monad-wordle} se divide en los modos \emph{mentemaestra} y \emph{descifrador},
que son, respectivamente, el modo de Computadora vs. Usuario y Usuario vs. Computadora.
El código fuente se encuentra dividido en los siguientes módulos:

\begin{itemize}
   \item \texttt{Wordle.Mastermind}: Contiene la función que ejecuta el modo \emph{mentemaestra}, usa las implementaciones de \texttt{Wordle.Utils.Checkers} para pedir una palabra del usuario, validarla e indicar los aciertos en el formato indicado, llevando control de las vidas y el historial.
   \item \texttt{Wordle.Decoder}: Contiene la función que ejecuta el modo decodificador, usa las implementaciones de \texttt{Wordle.Utils.Minimaxer} para pedir hacer una adivinación, pedir una pista al usuario y generar una siguiente.
   \begin{itemize}
      \item \texttt{Wordle.Utils.IOHelpers}: Contiene funciones de ayuda para las operaciones de entrada-salida, que involucra la carga del archivo de palabras, la escogencia de una palabra al azar y la impresión del historial para el modo \emph{mentemaestra}.
      \item \texttt{Wordle.Utils.Checkers}: Contiene las funciones que validan y evalúan la adivinación del usuario en el modo \emph{mentemaestra}.
      \item \texttt{Wordle.Utils.Minimaxer}: Contiene las funciones que implementan el agente de Minimax solucionador del modo \emph{descifrador}.
   \end{itemize}
\end{itemize}

Luego, la primera consideración de eficiencia tomada en la implementación de \texttt{monad-wordle} fue con respecto al cargado de la lista de palabras del archivo dado. \\

Dado que el archivo contiene alrededor de $10.500$ palabras, y constantemente se realizan búsquedas de palabras en ambos modos de juego, se decidió usar la estructura de datos \texttt{Data.Set} de Haskell para almacenarlas en memoria principal. La implementación interna de \texttt{Data.Set} se trata de un árbol binario autobalanceable, y el archivo de palabras está ordenado en orden lexicográfico ascendente, lo cual permite incluso construir el árbol en tiempo asintótico $O(n)$, y no $(n\lg n)$, por lo cual no hay pérdidas de eficiencia notables respecto al tiempo que tardaría en cargarse en una lista. \\

Sin embargo, la mayor de las ventajas de este acercamiento con \texttt{Data.Set} es que la búsqueda de un elemento en este ocurre en tiempo logarítmico con respecto al tamaño del conjunto, por lo que para validar la respuesta del usuario se recorren menos de 16 nodos (a diferencia de las listas, cuyo tiempo de búsqueda es lineal), resultando en un ahorro de cómputo considerable.

\subsection{Modo \emph{mentemaestra}}

Para validar las entradas del usuario se decidió usar el tipo de datos \texttt{Either}, el cual es una característica útil de Haskell para el manejo de errores sin excepciones, a la vez que se mantiene el tipado fuerte y estático y la pureza funcional. Se retorna \texttt{Left} con un mensaje de error en caso de una validación fallida, y \texttt{Right} en caso contrario, con la palabra convertida a mayúsculas y sin acentos. \\

El algoritmo usado para producir la cadena de Toros y Vacas para el usuario
consiste en verificar primero los Toros y luego las Vacas. Para verificar los 
Toros se comparan uno a uno la respuesta de la computadora con la adivinación 
del usuario, ya que los Toros indican una coincidencia exacta en la posición; 
luego de verificar los Toros, la función retorna la cadena constuída 
considerando solo Toros y los caracteres restantes por adivinar de la palabra 
de la computadora, retorno que es directamente pasado a la función que 
verifica las Vacas, que solo chequea que si letras del usuario forman parte 
del restante por adivinar, independientemente de su posición exacta. Cuando se 
encuentra membresía de una letra en la palabra de la computadora, se marca la 
Vaca y se sigue revisando, removiéndose la letra del conjunto de caracteres 
restantes por adivinar, y esto garantiza que se maneja bien cualquier caso 
borde de letras repetidas, en los cuales solo se marcan dos o más veces, o 
solo la primera según sea el caso. \\

Con respecto a la validación de la palabra dada por el jugador, las 
verificaciones, aunque son todas computacionalmente livianas, se hacen desde 
la más liviana hasta la más pesada: i) que la palabra tenga 5 letras, b) que 
todos sus caracteres sean alfabéticos y iii) que pertenezca al conjunto de 
palabras, habiéndose llevado a cabo antes de ello una uniformización de la 
entrada del usuario, convirtiéndola a mayúsculas removiendo los acentos agudos. \\

Por ser sencillo de implementar, se decidió mantener el historial de intentos 
(la matriz de Toros y Vacas) para compartir el resultado, consistiendo en 
concatenar cada intento, de ser válido, a la cabeza de una lista de \texttt
{String} en cada llamada recursiva, para ser impresa al final en orden inverso.

\subsection{Modo \emph{descifrador}}

En este modo se presentaron más dificultades, pues principalmente la creación 
de un árbol a lo sumo 10-ario con 4 niveles de profundidad es un cálculo
computacionalmente intenso y el planteamiento en programación funcional de la
construcción del agente Minimax resulta complejo al no estar acostumbrados a
pensar en este paradigma de resolución de problemas, sin embargo, al lograr
conseguir la solución se puede notar por qué es este un problema adecuado para
resolverse en un lenguaje de programación declarativo con más facilidad que en uno imperativo. \\

Para el modelado del problema se usaron las siguientes extructuras de Datos:

\begin{minted}{haskell}
data Guess = Guess String Int
data Score = Score String Int
data Rose a = Leaf a | Node a [Rose a]
data MinimaxNode = MinimaxNode {
    value    :: String,
    wordSet  :: Set Guess,
    scoreSet :: Set Score,
    score    :: Int
} 
\end{minted}

Al tener que generar un árbol con cantidad no acotada y probablemente variable
de nodos hijo, se decidió implementar la estructura de datos \texttt{Rose}. Por
otro lado, se modelan las Strings de adivinación y calificación del usuario con
los registros \texttt{Guess} y \texttt{Score}, respectivamente, cada uno de los
cuales contiene una String y su calificación, de acuerdo a la dada en el enunciado. \\

De tal manera, se diseñaron funciones que dada una String crean el
\texttt{Score} o la \texttt{Guess} con su puntuación correspondiente. Como la
creación del árbol es costosa, se decidió usar un \texttt{Int} para representar las 
puntuaciones con más precisión y hacer cálculos con mayor rapidez, siendo estas el
resultado de multiplicar por 10 la puntuación del enunciado. Además, en el caso del
cálculo de los \texttt{Score}, para evitar que cada String valga 10 y se reste 2 o 1
por cada Toro o Vaca, se cambió el esquema de puntuación a uno análogo que no usa
resta, sino que suma 0 por cada Toro, 1 por cada Vaca y 2 por cada guión, siendo
las puntuaciones resultantes equivalentes. \\

Luego, se guarda el estado del juego en cada ronda en dos conjuntos, un
\texttt{Set Guess} y un \texttt{Set Score}, que contienen estos las palabras que
sirven de posible adivinación y posible calificación del usuario en la ronda actual,
respectivamente. Así, se aprovecha la implementación de Haskell de \texttt{Set} como
un árbol binario de búsqueda para implementar la typeclass \texttt{Ord} en \texttt{Guess} y \texttt{Score}, de forma que al crear cada conjunto se tengan las
adivinaciones posibles en orden ascendente de puntuación, y las puntuaciones posibles
del usuario en orden descendente de puntuación, que servirá posteriormente para
simplificar la construcción del árbol Minimax. \\

Estos conjuntos se crean y calculan una sola vez durante todo el programa. En el caso
del \texttt{Set Guess} se pasan todas las palabras del \texttt{Set String}, cargadas en
\texttt{Main} a \texttt{Guess}, y se usa la comprensión de listas de Haskell para
obtener todas las combinaciones posibles de 5 letras de \texttt{`-'}, \texttt{`V'} y
\texttt{`T'}. \\

Por otro lado, se diseñaron distintos algoritmos para aprovechar al máximo las pistas
del usuario

\section{Conclusiones}

El algoritmo presentado para resolver el \emph{problema del cartero rural} (RPP),
su implementación en \texttt{grafoLib} y los resultados 
experimentales obtenidos permiten concluir que:

\begin{itemize}
   \item Sin tomar el elevado tiempo exponencial característico de
   los algoritmos de fuerza bruta que solucionan los problemas
   \emph{NP-complejo}, un algoritmo heurístico puede ayudar a obtener
   soluciones no tan alejadas de las óptimas, las cuales puede ser
   útiles en ciertas aplicaciones, y requerir un tiempo muchísimo
   menor.

   \item Los algoritmos sobre grafos vistos en el curso sirven
   para resolver variedades de problemas, tanto computacionales
   como en otras áreas. En este caso, fueron de utilidad algoritmos
   para obtener árboles mínimos cobertores, apareamientos perfectos,
   componentes conexas y caminos de costo mínimo (juntos con sus
   costos).

   \item Aunque para resolver esta implementación se necesitó de 
   un isomorfismo entre dos grafos con vértices representados con 
   números naturales, se observó que los grafos isomorfos son de
   gran utilidad para mapear grafos de cualquier tipo a grafos de
   números naturales en un intervalo, de forma que se mantiene una
   implementación sencilla a la vez que se pueden resolver problemas
   que requieran grafos con vértices de otro tipo (como cadenas de
   caracteres e incluso objetos). Además, es útil y eficiente para
   la implementación de la función $f$ del isomorfismo el uso de arreglos
   y diccionarios como tablas de hash, que toman tiempo lineal en su
   creación pero luego tiempo amortizado constante en su acceso.

   \item Si bien se sabe que una estrategia ávida no necesariamente
   obtiene la mejor solución a los problemas, son en su mayoría
   sencillas de implementar y pueden usarse para resolver partes
   de problemas más grandes proporcionando soluciones razonablemente
   cercanas a la óptima.

   \item Las ideas y algoritmos sobre grafos dirigidos pueden, en
   muchos casos, extenderse a grafos no dirigidos, teniendo cuenta
   de la ``orientación'' de las aristas y considerando que siempre se 
   tiene que los lados $(u, v)$ y $(v, u)$ son iguales.

   \item Cuando se dispone de suficiente tiempo y recursos, puede
   resultar beneficioso implementar y ejecutar varias veces un
   algoritmo que explora el espacio de soluciones para obtener
   soluciones mejores que la de los algoritmos deterministas, 
   especialmente si el tiempo de ejecución del algoritmo no
   determinista es similar o mejor que el determinista.

   \item Modelar problemas con grafos proporciona en la mayoría de
   los casos poderosas herramientas para resolver desde problemas
   cotidianos a complejos, de forma argumentablemente más sencilla
   a si se buscase resolver los mismos problemas con el uso de 
   otras estructuras matemáticas o de datos.

\end{itemize}

\end{document}